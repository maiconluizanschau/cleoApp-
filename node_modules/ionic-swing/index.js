import { Component, ElementRef, EventEmitter, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import _ from 'underscore';
import Sister from 'sister';
import rebound from 'rebound';
import vendorPrefix from 'vendor-prefix';
import raf from 'raf';

var Direction = {
    DOWN: Symbol('DOWN'),
    INVALID: Symbol('INVALID'),
    LEFT: Symbol('LEFT'),
    RIGHT: Symbol('RIGHT'),
    UP: Symbol('UP')
};

/**
 * Return direct children elements.
 *
 * @see http://stackoverflow.com/a/27102446/368691
 */
var elementChildren = function (element) {
    return _.filter(element.childNodes, function (elem) {
        return elem.nodeType === 1;
    });
};
/**
 * @see http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript/4819886#4819886
 */
var isTouchDevice = function () {
    return 'ontouchstart' in window || navigator.msMaxTouchPoints;
};

/**
 * @param {number} fromX
 * @param {number} fromY
 * @param {Direction[]} allowedDirections
 * @returns {Direction[]} computed direction
 */
var computeDirection = function (fromX, fromY, allowedDirections) {
    var /** @type {?} */ isHorizontal = Math.abs(fromX) > Math.abs(fromY);
    var /** @type {?} */ isLeftDirection = fromX < 0 ? Direction.LEFT : Direction.RIGHT;
    var /** @type {?} */ isUpDirection = fromY < 0 ? Direction.UP : Direction.DOWN;
    var /** @type {?} */ direction = isHorizontal ? isLeftDirection : isUpDirection;
    if (allowedDirections.indexOf(direction) === -1) {
        return Direction.INVALID;
    }
    return direction;
};
/**
 * Prepend element to the parentNode.
 *
 * This makes the element last among the siblings.
 *
 * Invoked when card is added to the stack (when prepend is true).
 *
 */
var prependToParent = function (element) {
    var parentNode = element.parentNode;
    parentNode.removeChild(element);
    parentNode.insertBefore(element, parentNode.firstChild);
};
/**
 * Append element to the parentNode.
 *
 * This makes the element first among the siblings. The reason for using
 * this as opposed to zIndex is to allow CSS selector :nth-child.
 *
 * Invoked in the event of mousedown.
 * Invoked when card is added to the stack.
 *
 */
var appendToParent = function (element) {
    var parentNode = element.parentNode;
    var siblings = elementChildren(parentNode);
    var targetIndex = siblings.indexOf(element);
    if (targetIndex + 1 !== siblings.length) {
        parentNode.removeChild(element);
        parentNode.appendChild(element);
    }
};
/**
 * Uses CSS transform to translate element position and rotation.
 *
 * Invoked in the event of `dragmove` and every time the physics solver is triggered.
 *
 */
var transform = function (element, coordinateX, coordinateY, rotation) {
    element.style[vendorPrefix('transform')] = 'translate3d(0, 0, 0) translate(' + coordinateX + 'px, ' + coordinateY + 'px) rotate(' + rotation + 'deg)';
};
/**
 * Returns a value between 0 and 1 indicating the completeness of the throw out condition.
 *
 * Ration of the absolute distance from the original card position and element width.
 *
 */
var throwOutConfidence = function (xOffset, yOffset, element) {
    var xConfidence = Math.min(Math.abs(xOffset) / element.offsetWidth, 1);
    var yConfidence = Math.min(Math.abs(yOffset) / element.offsetHeight, 1);
    return Math.max(xConfidence, yConfidence);
};
/**
 * Determines if element is being thrown out of the stack.
 *
 * Element is considered to be thrown out when throwOutConfidence is equal to 1.
 *
 */
var isThrowOut = function (xOffset, yOffset, element, throwOutConfidence) {
    return throwOutConfidence === 1;
};
/**
 * Calculates a distances at which the card is thrown out of the stack.
 *
 */
var throwOutDistance = function (min, max) {
    return _.random(min, max);
};
/**
 * Calculates rotation based on the element x and y offset, element width and maxRotation variables.
 *
 */
var rotation = function (coordinateX, coordinateY, element, maxRotation) {
    var horizontalOffset = Math.min(Math.max(coordinateX / element.offsetWidth, -1), 1);
    var verticalOffset = (coordinateY > 0 ? 1 : -1) * Math.min(Math.abs(coordinateY) / 100, 1);
    var calculatedRotation = horizontalOffset * verticalOffset * maxRotation;
    return calculatedRotation;
};
var THROW_IN = 'in';
var THROW_OUT = 'out';
/**
 * Creates a configuration object.
 *
 */
var makeConfig = function (config) {
    if (config === void 0) { config = {}; }
    var defaultConfig = {
        allowedDirections: [
            Direction.RIGHT,
            Direction.LEFT,
            Direction.UP
        ],
        isThrowOut: isThrowOut,
        maxRotation: 20,
        maxThrowOutDistance: 500,
        minThrowOutDistance: 400,
        rotation: rotation,
        throwOutConfidence: throwOutConfidence,
        throwOutDistance: throwOutDistance,
        transform: transform
    };
    return _.assign({}, defaultConfig, config);
};
/**
 * @param {Stack} stack
 * @param {HTMLElement} targetElement
 * @param {boolean} prepend
 * @returns {Object} An instance of Card.
 */
var Card = function (stack, targetElement, prepend) {
    var /** @type {?} */ card;
    var /** @type {?} */ config;
    var /** @type {?} */ currentX;
    var /** @type {?} */ currentY;
    var /** @type {?} */ doMove;
    var /** @type {?} */ eventEmitter;
    var /** @type {?} */ isDraging;
    var /** @type {?} */ isPanning;
    var /** @type {?} */ lastThrow;
    var /** @type {?} */ lastTranslate;
    var /** @type {?} */ lastX;
    var /** @type {?} */ lastY;
    var /** @type {?} */ mc;
    var /** @type {?} */ onSpringUpdate;
    var /** @type {?} */ springSystem;
    var /** @type {?} */ springThrowIn;
    var /** @type {?} */ springThrowOut;
    var /** @type {?} */ throwDirectionToEventName;
    var /** @type {?} */ throwOutDistance;
    var /** @type {?} */ throwWhere;
    var /** @type {?} */ construct = function () {
        card = {};
        config = makeConfig(stack.getConfig());
        eventEmitter = Sister();
        springSystem = stack.getSpringSystem();
        springThrowIn = springSystem.createSpring(250, 10);
        springThrowOut = springSystem.createSpring(500, 20);
        lastThrow = {};
        lastTranslate = {
            coordinateX: 0,
            coordinateY: 0
        };
        /* Mapping directions to event names */
        throwDirectionToEventName = {};
        throwDirectionToEventName[Direction.LEFT] = 'throwoutleft';
        throwDirectionToEventName[Direction.RIGHT] = 'throwoutright';
        throwDirectionToEventName[Direction.UP] = 'throwoutup';
        throwDirectionToEventName[Direction.DOWN] = 'throwoutdown';
        springThrowIn.setRestSpeedThreshold(0.05);
        springThrowIn.setRestDisplacementThreshold(0.05);
        springThrowOut.setRestSpeedThreshold(0.05);
        springThrowOut.setRestDisplacementThreshold(0.05);
        throwOutDistance = config.throwOutDistance(config.minThrowOutDistance, config.maxThrowOutDistance);
        mc = new Hammer.Manager(targetElement, {
            recognizers: [
                [
                    Hammer.Pan,
                    {
                        threshold: 2
                    }
                ]
            ]
        });
        if (prepend) {
            prependToParent(targetElement);
        }
        else {
            appendToParent(targetElement);
        }
        eventEmitter.on('panstart', function () {
            appendToParent(targetElement);
            eventEmitter.trigger('dragstart', {
                target: targetElement
            });
            currentX = 0;
            currentY = 0;
            isDraging = true;
            (function animation() {
                if (isDraging) {
                    doMove();
                    raf(animation);
                }
            })();
        });
        eventEmitter.on('panmove', function (event) {
            currentX = event.deltaX;
            currentY = event.deltaY;
        });
        eventEmitter.on('panend', function (event) {
            isDraging = false;
            var /** @type {?} */ coordinateX = lastTranslate.coordinateX + event.deltaX;
            var /** @type {?} */ coordinateY = lastTranslate.coordinateY + event.deltaY;
            var /** @type {?} */ isThrowOut = config.isThrowOut(coordinateX, coordinateY, targetElement, config.throwOutConfidence(coordinateX, coordinateY, targetElement));
            // Not really sure about computing direction here and filtering on directions here.
            // It adds more logic. Any suggestion will be appreciated.
            var /** @type {?} */ direction = computeDirection(coordinateX, coordinateY, config.allowedDirections);
            if (isThrowOut && direction !== Direction.INVALID) {
                card.throwOut(coordinateX, coordinateY, direction);
            }
            else {
                card.throwIn(coordinateX, coordinateY, direction);
            }
            eventEmitter.trigger('dragend', {
                target: targetElement
            });
        });
        // "mousedown" event fires late on touch enabled devices, thus listening
        // to the touchstart event for touch enabled devices and mousedown otherwise.
        if (isTouchDevice()) {
            targetElement.addEventListener('touchstart', function () {
                eventEmitter.trigger('panstart');
            });
            targetElement.addEventListener('touchend', function () {
                if (isDraging && !isPanning) {
                    eventEmitter.trigger('dragend', {
                        target: targetElement
                    });
                }
            });
            // Disable scrolling while dragging the element on the touch enabled devices.
            // @see http://stackoverflow.com/a/12090055/368691
            (function () {
                var /** @type {?} */ dragging;
                targetElement.addEventListener('touchstart', function () {
                    dragging = true;
                });
                targetElement.addEventListener('touchend', function () {
                    dragging = false;
                });
                global.addEventListener('touchmove', function (event) {
                    if (dragging) {
                        event.preventDefault();
                    }
                });
            })();
        }
        else {
            targetElement.addEventListener('mousedown', function () {
                eventEmitter.trigger('panstart');
            });
            targetElement.addEventListener('mouseup', function () {
                if (isDraging && !isPanning) {
                    eventEmitter.trigger('dragend', {
                        target: targetElement
                    });
                }
            });
        }
        mc.on('panstart', function (event) {
            isPanning = true;
        });
        mc.on('panmove', function (event) {
            eventEmitter.trigger('panmove', event);
        });
        mc.on('panend', function (event) {
            isPanning = false;
            eventEmitter.trigger('panend', event);
        });
        springThrowIn.addListener({
            onSpringAtRest: function () {
                eventEmitter.trigger('throwinend', {
                    target: targetElement
                });
            },
            onSpringUpdate: function (spring) {
                var /** @type {?} */ value = spring.getCurrentValue();
                var /** @type {?} */ coordianteX = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromX, 0);
                var /** @type {?} */ coordianteY = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromY, 0);
                onSpringUpdate(coordianteX, coordianteY);
            }
        });
        springThrowOut.addListener({
            onSpringAtRest: function () {
                eventEmitter.trigger('throwoutend', {
                    target: targetElement
                });
            },
            onSpringUpdate: function (spring) {
                var /** @type {?} */ value = spring.getCurrentValue();
                var /** @type {?} */ coordianteX;
                var /** @type {?} */ coordianteY;
                var /** @type {?} */ directionFactor;
                if (lastThrow.direction === Direction.RIGHT || lastThrow.direction === Direction.LEFT) {
                    directionFactor = lastThrow.direction === Direction.RIGHT ? 1 : -1;
                    coordianteX = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromX, throwOutDistance * directionFactor);
                    coordianteY = lastThrow.fromY;
                }
                else if (lastThrow.direction === Direction.UP || lastThrow.direction === Direction.DOWN) {
                    directionFactor = lastThrow.direction === Direction.DOWN ? 1 : -1;
                    coordianteX = lastThrow.fromX;
                    coordianteY = rebound.MathUtil.mapValueInRange(value, 0, 1, lastThrow.fromY, throwOutDistance * directionFactor);
                }
                onSpringUpdate(coordianteX, coordianteY);
            }
        });
        /**
         * Transforms card position based on the current environment variables.
         *
         * @returns {undefined}
         */
        doMove = function () {
            if (currentX === lastX && currentY === lastY) {
                return;
            }
            lastX = currentX;
            lastY = currentY;
            var /** @type {?} */ coordinateX = lastTranslate.coordinateX + currentX;
            var /** @type {?} */ coordianteY = lastTranslate.coordinateY + currentY;
            var /** @type {?} */ rotation = config.rotation(coordinateX, coordianteY, targetElement, config.maxRotation);
            config.transform(targetElement, coordinateX, coordianteY, rotation);
            eventEmitter.trigger('dragmove', {
                offset: coordinateX,
                target: targetElement,
                throwDirection: computeDirection(coordinateX, coordianteY, config.allowedDirections),
                throwOutConfidence: config.throwOutConfidence(coordinateX, coordianteY, targetElement)
            });
        };
        /**
         * Invoked every time the physics solver updates the Spring's value.
         *
         * @param {number} coordinateX
         * @param {number} coordinateY
         * @returns {undefined}
         */
        onSpringUpdate = function (coordinateX, coordinateY) {
            var /** @type {?} */ rotation = config.rotation(coordinateX, coordinateY, targetElement, config.maxRotation);
            lastTranslate.coordinateX = coordinateX || 0;
            lastTranslate.coordinateY = coordinateY || 0;
            config.transform(targetElement, coordinateX, coordinateY, rotation);
        };
        /**
         * @param {THROW_IN|THROW_OUT} where
         * @param {number} fromX
         * @param {number} fromY
         * @param {Direction} [direction]
         * @returns {undefined}
         */
        throwWhere = function (where, fromX, fromY, direction) {
            lastThrow.fromX = fromX;
            lastThrow.fromY = fromY;
            // If direction argument is not set, compute it from coordinates.
            lastThrow.direction = direction || computeDirection(fromX, fromY, config.allowedDirections);
            if (where === THROW_IN) {
                springThrowIn.setCurrentValue(0).setAtRest().setEndValue(1);
                eventEmitter.trigger('throwin', {
                    target: targetElement,
                    throwDirection: lastThrow.direction
                });
            }
            else if (where === THROW_OUT) {
                springThrowOut.setCurrentValue(0).setAtRest().setVelocity(100).setEndValue(1);
                eventEmitter.trigger('throwout', {
                    target: targetElement,
                    throwDirection: lastThrow.direction
                });
                /* Emits more accurate events about specific directions */
                eventEmitter.trigger(throwDirectionToEventName[lastThrow.direction], {
                    target: targetElement,
                    throwDirection: lastThrow.direction
                });
            }
            else {
                throw new Error('Invalid throw event.');
            }
        };
    };
    construct();
    /**
     * Alias
     */
    card.on = eventEmitter.on;
    card.trigger = eventEmitter.trigger;
    /**
     * Throws a card into the stack from an arbitrary position.
     *
     * @param {number} coordinateX
     * @param {number} coordinateY
     * @param {Direction} [direction]
     * @returns {undefined}
     */
    card.throwIn = function (coordinateX, coordinateY, direction) {
        throwWhere(THROW_IN, coordinateX, coordinateY, direction);
    };
    /**
     * Throws a card out of the stack in the direction away from the original offset.
     *
     * @param {number} coordinateX
     * @param {number} coordinateY
     * @param {Direction} [direction]
     * @returns {undefined}
     */
    card.throwOut = function (coordinateX, coordinateY, direction) {
        throwWhere(THROW_OUT, coordinateX, coordinateY, direction);
    };
    /**
     * Unbinds all Hammer.Manager events.
     * Removes the listeners from the physics simulation.
     *
     * @returns {undefined}
     */
    card.destroy = function () {
        mc.destroy();
        springThrowIn.destroy();
        springThrowOut.destroy();
        stack.destroyCard(card);
    };
    return card;
};

/**
 * @param {Object} config Stack configuration.
 * @returns {Object} An instance of Stack object.
 */
var Stack = function (config) {
    var /** @type {?} */ eventEmitter;
    var /** @type {?} */ index;
    var /** @type {?} */ springSystem;
    var /** @type {?} */ stack;
    var /** @type {?} */ construct = function () {
        stack = {};
        springSystem = new rebound.SpringSystem();
        eventEmitter = Sister();
        index = [];
    };
    construct();
    /**
     * Get the configuration object.
     *
     * @returns {Object}
     */
    stack.getConfig = function () {
        return config;
    };
    /**
     * Get a singleton instance of the SpringSystem physics engine.
     *
     * @returns {Sister}
     */
    stack.getSpringSystem = function () {
        return springSystem;
    };
    /**
     * Proxy to the instance of the event emitter.
     *
     * @param {string} eventName
     * @param {string} listener
     * @returns {undefined}
     */
    stack.on = function (eventName, listener) {
        eventEmitter.on(eventName, listener);
    };
    /**
     * Creates an instance of Card and associates it with an element.
     *
     * @param {HTMLElement} element
     * @param {boolean} prepend
     * @returns {Card}
     */
    stack.createCard = function (element, prepend) {
        var /** @type {?} */ card = Card(stack, element, prepend);
        var /** @type {?} */ events = [
            'throwout',
            'throwoutend',
            'throwoutleft',
            'throwoutright',
            'throwoutup',
            'throwoutdown',
            'throwin',
            'throwinend',
            'dragstart',
            'dragmove',
            'dragend'
        ];
        // Proxy Card events to the Stack.
        events.forEach(function (eventName) {
            card.on(eventName, function (data) {
                eventEmitter.trigger(eventName, data);
            });
        });
        index.push({
            card: card,
            element: element
        });
        return card;
    };
    /**
     * Returns an instance of Card associated with an element.
     *
     * @param {HTMLElement} element
     * @returns {Card|null}
     */
    stack.getCard = function (element) {
        var /** @type {?} */ group = _.find(index, function (i) {
            return _.isEqual(i, element);
        });
        if (group) {
            return group.card;
        }
        return null;
    };
    /**
     * Remove an instance of Card from the stack index.
     *
     * @param {Card} card
     * @returns {null}
     */
    stack.destroyCard = function (card) {
        return _.remove(index, {
            card: card
        });
    };
    return stack;
};

var SwingStackComponent = (function () {
    function SwingStackComponent() {
        this.throwout = new EventEmitter();
        this.throwoutend = new EventEmitter();
        this.throwoutleft = new EventEmitter();
        this.throwoutright = new EventEmitter();
        this.throwoutup = new EventEmitter();
        this.throwoutdown = new EventEmitter();
        this.throwin = new EventEmitter();
        this.throwinend = new EventEmitter();
        this.dragstart = new EventEmitter();
        this.dragmove = new EventEmitter();
        this.dragend = new EventEmitter();
        this.cards = [];
    }
    /**
     * @param {?} card
     * @return {?}
     */
    SwingStackComponent.prototype.addCard = function (card) {
        this.cards.push(card);
        if (this.stack) {
            this.stack.createCard(card.getNativeElement());
        }
    };
    /**
     * @return {?}
     */
    SwingStackComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.stack = Stack(this.stackConfig || {});
        this.cards.forEach(function (c) { return _this.stack.createCard(c.getNativeElement()); });
        // Hook various events
        this.stack.on('throwout', function ($event) { return _this.throwout.emit($event); });
        this.stack.on('throwoutend', function ($event) { return _this.throwoutend.emit($event); });
        this.stack.on('throwoutleft', function ($event) { return _this.throwoutleft.emit($event); });
        this.stack.on('throwoutright', function ($event) { return _this.throwoutright.emit($event); });
        this.stack.on('throwin', function ($event) { return _this.throwin.emit($event); });
        this.stack.on('throwinend', function ($event) { return _this.throwinend.emit($event); });
        this.stack.on('dragstart', function ($event) { return _this.dragstart.emit($event); });
        this.stack.on('dragmove', function ($event) { return _this.dragmove.emit($event); });
        this.stack.on('dragend', function ($event) { return _this.dragend.emit($event); });
        this.stack.on('throwoutup', function ($event) { return _this.throwoutup.emit($event); });
        this.stack.on('throwoutdown', function ($event) { return _this.throwoutdown.emit($event); });
    };
    return SwingStackComponent;
}());
SwingStackComponent.decorators = [
    { type: Component, args: [{
                selector: '[swing-stack]',
                template: "\n        <ng-content></ng-content>\n    ",
                outputs: [
                    'throwout',
                    'throwoutend',
                    'throwoutleft',
                    'throwoutright',
                    'throwoutup',
                    'throwoutdown',
                    'throwin',
                    'throwinend',
                    'dragstart',
                    'dragmove',
                    'dragend',
                ]
            },] },
];
/**
 * @nocollapse
 */
SwingStackComponent.ctorParameters = function () { return []; };
SwingStackComponent.propDecorators = {
    'stackConfig': [{ type: Input },],
};

var SwingCardComponent = (function () {
    /**
     * @param {?} elmentRef
     * @param {?} swingStack
     */
    function SwingCardComponent(elmentRef, swingStack) {
        this.elmentRef = elmentRef;
        this.swingStack = swingStack;
    }
    /**
     * @return {?}
     */
    SwingCardComponent.prototype.ngOnInit = function () {
        this.swingStack.addCard(this);
    };
    /**
     * @return {?}
     */
    SwingCardComponent.prototype.getElementRef = function () {
        return this.elmentRef;
    };
    /**
     * @return {?}
     */
    SwingCardComponent.prototype.getNativeElement = function () {
        return this.elmentRef.nativeElement;
    };
    /**
     * @return {?}
     */
    SwingCardComponent.prototype.getCard = function () {
        return this.swingStack.stack.getCard(this.getNativeElement());
    };
    return SwingCardComponent;
}());
SwingCardComponent.decorators = [
    { type: Component, args: [{
                selector: '[swing-card]',
                template: "\n        <ng-content></ng-content>\n    "
            },] },
];
/**
 * @nocollapse
 */
SwingCardComponent.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: SwingStackComponent, },
]; };

var IonicSwingModule = (function () {
    function IonicSwingModule() {
    }
    /**
     * @return {?}
     */
    IonicSwingModule.forRoot = function () {
        return {
            ngModule: IonicSwingModule
        };
    };
    return IonicSwingModule;
}());
IonicSwingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    SwingStackComponent,
                    SwingCardComponent
                ],
                exports: [
                    SwingStackComponent,
                    SwingCardComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
IonicSwingModule.ctorParameters = function () { return []; };

export { IonicSwingModule, SwingStackComponent, SwingCardComponent, Direction, Stack, elementChildren, isTouchDevice };export default Card;
